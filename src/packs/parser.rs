use glob::glob;
use lib_ruby_parser::{
    nodes, traverse::visitor::Visitor, Node, Parser, ParserOptions,
};
use rayon::prelude::*;
use serde::{Deserialize, Serialize};
use std::{
    fs,
    path::{Path, PathBuf},
};

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Reference {
    pub name: String,
    pub module_nesting: Vec<String>,
    pub location: Range,
}

pub struct ParsedReference {
    pub name: String,
    pub module_nesting: Vec<String>,
    pub location: Location,
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Range {
    pub start_row: usize,
    pub start_col: usize,
    pub end_row: usize,
    pub end_col: usize,
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Location {
    pub begin: usize,
    pub end: usize,
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct LocationRange {
    pub start: Location,
    pub end: Location,
}

struct ReferenceCollector {
    pub references: Vec<ParsedReference>,
    pub current_namespaces: Vec<String>,
}

fn fetch_const_name(node: &nodes::Node) -> String {
    match node {
        Node::Const(const_node) => fetch_const_const_name(const_node),
        Node::Cbase(_) => String::from(""),
        _ => {
            panic!("Cannot handle other node in get_constant_node_name.")
        }
    }
}

fn fetch_const_const_name(node: &nodes::Const) -> String {
    match &node.scope {
        Some(s) => {
            let parent_namespace = fetch_const_name(s);
            format!("{}::{}", parent_namespace, node.name)
        }
        None => node.name.to_owned(),
    }
}

impl Visitor for ReferenceCollector {
    fn on_class(&mut self, node: &nodes::Class) {
        // We're not collecting definitions, so no need to visit the class definition
        // self.visit(&node.name);
        let namespace = fetch_const_name(&node.name);
        // We're not visiting super classes either
        // if let Some(inner) = node.superclass.as_ref() {
        //     self.visit(inner);
        // }

        // Note – is there a way to use lifetime specifiers to get rid of this and
        // just keep current namespaces as a vector of string references or something else
        // more efficient?
        self.current_namespaces.push(namespace);

        if let Some(inner) = &node.body {
            self.visit(inner);
        }

        self.current_namespaces.pop();
    }

    // TODO: extract the common stuff from on_class
    fn on_module(&mut self, node: &nodes::Module) {
        let namespace = fetch_const_name(&node.name);
        self.current_namespaces.push(namespace);

        if let Some(inner) = &node.body {
            self.visit(inner);
        }

        self.current_namespaces.pop();
    }

    fn on_const(&mut self, node: &nodes::Const) {
        self.references.push(ParsedReference {
            name: fetch_const_const_name(node),
            module_nesting: calculate_module_nesting(&self.current_namespaces),
            location: Location {
                begin: node.expression_l.begin,
                end: node.expression_l.end,
            },
        })
    }
}

// This function takes a list (`namespace_nesting`) that represents
// the level of class and module nesting at a given location in code
// and outputs the value of `Module.nesting` at that location.
// This function may have bugs! Please provide your feedback.
// I hope to iterate on it to produce an accurate-to-spec implementation
// of `Module.nesting` given the current namespace. Some bugs may involve
// improving on how the input `namespace_nesting` is generated by the
// AST visitor.
//
// # Example:
// class Foo
//   module Bar
//     class Baz
//       puts Module.nesting.inspect
//     end
//   end
// end
// # inputs: ['Foo', 'Bar', 'Baz']
// # outputs: ['Foo::Bar::Baz', 'Foo::Bar', 'Foo']
fn calculate_module_nesting(namespace_nesting: &[String]) -> Vec<String> {
    let mut nesting = Vec::new();
    let mut previous = String::from("");
    namespace_nesting.iter().for_each(|namespace| {
        let new_nesting: String = if previous.is_empty() {
            namespace.to_owned()
        } else {
            format!("{}::{}", previous, namespace)
        };

        previous = new_nesting.to_owned();
        nesting.insert(0, new_nesting);
    });

    nesting
}

pub fn get_references(absolute_root: &Path) -> Vec<Reference> {
    // Later this can come from config
    let pattern = absolute_root.join("packs/**/*.rb");

    let x = glob(pattern.to_str().unwrap())
        .expect("Failed to read glob pattern")
        .par_bridge() // Parallel iterator
        .flat_map(|entry| match entry {
            Ok(path) => extract_from_path(&path),
            Err(e) => {
                println!("{:?}", e);
                panic!("blah");
            }
        })
        .collect();
    x
}

pub(crate) fn extract_from_path(path: &PathBuf) -> Vec<Reference> {
    // TODO: This can be a debug statement instead of a print
    // println!("Now parsing {:?}", path);
    let contents = fs::read_to_string(path).unwrap_or_else(|_| {
        panic!("Failed to read contents of {}", path.to_string_lossy())
    });

    extract_from_contents(contents)
}

fn extract_from_contents(contents: String) -> Vec<Reference> {
    let options = ParserOptions {
        buffer_name: "".to_string(),
        ..Default::default()
    };
    let parser = Parser::new(contents.clone(), options);
    let _ret = parser.do_parse();
    let ast = *_ret.ast.expect("No AST found!");

    let mut collector = ReferenceCollector {
        references: vec![],
        current_namespaces: vec![],
    };

    collector.visit(&ast);
    collector
        .references
        .into_iter()
        .map(|parsed_reference| Reference {
            name: parsed_reference.name,
            module_nesting: parsed_reference.module_nesting,
            location: convert_to_row_col(
                &contents,
                parsed_reference.location.begin,
                parsed_reference.location.end,
            )
            .unwrap(),
        })
        .collect()
}
fn convert_to_row_col(
    contents: &str,
    start_pos: usize,
    end_pos: usize,
) -> Option<Range> {
    let mut row = 1;
    let mut col = 1;
    let mut start_found = false;

    let mut start_row = 0;
    let mut start_col = 0;
    let mut end_row = 0;
    let mut end_col = 0;

    for (idx, ch) in contents.chars().enumerate() {
        if idx == start_pos {
            start_found = true;
            start_row = row;
            start_col = col;
            if start_pos == end_pos {
                end_row = row;
                end_col = col + 2; // Adjusted ending column calculation
                return Some(Range {
                    start_row,
                    start_col,
                    end_row,
                    end_col,
                });
            }
        }
        if idx == end_pos {
            end_row = row;
            end_col = col + 1;
            return Some(Range {
                start_row,
                start_col,
                end_row,
                end_col,
            });
        }

        if ch == '\n' {
            row += 1;
            col = 1;
        } else {
            col += 1;
        }

        if start_found {
            col -= 1; // Adjust the column to exclude the newline character
        }
    }

    None // Return None if the positions are out of bounds
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_trivial_case() {
        let contents: String = String::from("Foo");
        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Foo"),
                module_nesting: vec![],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    fn test_nested_constant() {
        let contents: String = String::from("Foo::Bar");
        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Foo::Bar"),
                module_nesting: vec![],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    fn test_deeply_nested_constant() {
        let contents: String = String::from("Foo::Bar::Baz");
        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Foo::Bar::Baz"),
                module_nesting: vec![],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    fn test_very_deeply_nested_constant() {
        let contents: String = String::from("Foo::Bar::Baz::Boo");
        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Foo::Bar::Baz::Boo"),
                module_nesting: vec![],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    fn test_class_definition() {
        let contents: String = String::from(
            "\
            class Foo
            end
        ",
        );

        assert_eq!(extract_from_contents(contents), vec![]);
    }

    #[test]
    fn test_class_namespaced_constant() {
        let contents: String = String::from(
            "\
class Foo
  Bar
end
        ",
        );

        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Bar"),
                module_nesting: vec![String::from("Foo")],
                location: Range {
                    start_row: 2,
                    start_col: 3,
                    end_row: 2,
                    end_col: 5
                }
            }]
        );
    }

    #[test]
    fn test_deeply_class_namespaced_constant() {
        let contents: String = String::from(
            "\
            class Foo
                class Bar
                    Baz
                end
            end
        ",
        );

        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Baz"),
                module_nesting: vec![
                    String::from("Foo::Bar"),
                    String::from("Foo")
                ],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    fn test_very_deeply_class_namespaced_constant() {
        let contents: String = String::from(
            "\
            class Foo
                class Bar
                    class Baz
                        Boo
                    end
                end
            end
        ",
        );

        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Boo"),
                module_nesting: vec![
                    String::from("Foo::Bar::Baz"),
                    String::from("Foo::Bar"),
                    String::from("Foo")
                ],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    fn test_module_namespaced_constant() {
        let contents: String = String::from(
            "\
            module Foo
                Bar
            end
        ",
        );

        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Bar"),
                module_nesting: vec![String::from("Foo")],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    fn test_deeply_module_namespaced_constant() {
        let contents: String = String::from(
            "\
            module Foo
                module Bar
                    Baz
                end
            end
        ",
        );

        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Baz"),
                module_nesting: vec![
                    String::from("Foo::Bar"),
                    String::from("Foo")
                ],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    fn test_very_deeply_module_namespaced_constant() {
        let contents: String = String::from(
            "\
            module Foo
                module Bar
                    module Baz
                        Boo
                    end
                end
            end
        ",
        );

        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Boo"),
                module_nesting: vec![
                    String::from("Foo::Bar::Baz"),
                    String::from("Foo::Bar"),
                    String::from("Foo")
                ],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    fn test_mixed_namespaced_constant() {
        let contents: String = String::from(
            "\
            class Foo
                module Bar
                    class Baz
                        Boo
                    end
                end
            end
        ",
        );

        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Boo"),
                module_nesting: vec![
                    String::from("Foo::Bar::Baz"),
                    String::from("Foo::Bar"),
                    String::from("Foo")
                ],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    // https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Style/ClassAndModuleChildren
    fn test_compact_style_class_definition_constant() {
        let contents: String = String::from(
            "\
            class Foo::Bar
                Baz
            end
        ",
        );

        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Baz"),
                module_nesting: vec![String::from("Foo::Bar")],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    // https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Style/ClassAndModuleChildren
    fn test_compact_style_with_nesting_class_definition_constant() {
        let contents: String = String::from(
            "\
            class Foo::Bar
                module Baz
                    Baz
                end
            end
        ",
        );

        assert_eq!(
            extract_from_contents(contents),
            vec![Reference {
                name: String::from("Baz"),
                module_nesting: vec![
                    String::from("Foo::Bar::Baz"),
                    String::from("Foo::Bar")
                ],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }]
        );
    }

    #[test]
    // https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Style/ClassAndModuleChildren
    fn test_array_of_constant() {
        let contents: String = String::from("[Foo]");
        let references = extract_from_contents(contents);
        assert_eq!(references.len(), 1);
        let reference = references
            .get(0)
            .expect("There should be a reference at index 0");
        assert_eq!(
            *reference,
            Reference {
                name: String::from("Foo"),
                module_nesting: vec![],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }
        );
    }
    #[test]
    // https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Style/ClassAndModuleChildren
    fn test_array_of_multiple_constants() {
        let contents: String = String::from("[Foo, Bar]");
        let references = extract_from_contents(contents);
        assert_eq!(references.len(), 2);
        let reference1 = references
            .get(0)
            .expect("There should be a reference at index 0");
        assert_eq!(
            *reference1,
            Reference {
                name: String::from("Foo"),
                module_nesting: vec![],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }
        );
        let reference2 = references
            .get(1)
            .expect("There should be a reference at index 1");
        assert_eq!(
            *reference2,
            Reference {
                name: String::from("Bar"),
                module_nesting: vec![],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }
        );
    }

    #[test]
    // https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Style/ClassAndModuleChildren
    fn test_array_of_nested_constant() {
        let contents: String = String::from("[Baz::Boo]");
        let references = extract_from_contents(contents);
        assert_eq!(references.len(), 1);
        let reference = references
            .get(0)
            .expect("There should be a reference at index 0");
        assert_eq!(
            *reference,
            Reference {
                name: String::from("Baz::Boo"),
                module_nesting: vec![],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }
        );
    }

    #[test]
    // https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Style/ClassAndModuleChildren
    fn test_globally_referenced_constant() {
        let contents: String = String::from("::Foo");
        let references = extract_from_contents(contents);
        assert_eq!(references.len(), 1);
        let reference = references
            .get(0)
            .expect("There should be a reference at index 0");
        assert_eq!(
            *reference,
            Reference {
                name: String::from("::Foo"),
                module_nesting: vec![],
                location: Range {
                    start_row: 1,
                    start_col: 1,
                    end_row: 1,
                    end_col: 3
                }
            }
        );
    }
}
